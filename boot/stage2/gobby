!obby
session version="0.4.7"
 user_table
  user colour="ccccff" id="1" name="leo"
 chat
  system_message text="leo est parmi nous" timestamp="1310307629"
  system_message text="leo has created a new document: linker.ld" timestamp="1310307635"
  system_message text="leo has created a new document: Makefile" timestamp="1310307640"
  system_message text="leo has created a new document: stage2.c" timestamp="1310307645"
  system_message text="leo has created a new document: stage2.s" timestamp="1310307649"
  system_message text="leo has created a new document: stage2.h" timestamp="1310307653"
  system_message text="leo has created a new document: printf.c" timestamp="1310307656"
  system_message text="leo has created a new document: io.c" timestamp="1310307665"
  system_message text="leo has created a new document: disk.c" timestamp="1310307668"
 document encoding="UTF-8" id="1" owner="1" suffix="1" title="linker.ld"
  chunk author="0" content="ENTRY(main)\nSECTIONS\n{\n\t.text 0x100000 :\n\t{\n\t\tcode = .; _code = .; __code = .;\n\t\t*(.text)\n\t\t. = ALIGN(4096);\n\t}\n\t\n\t.data :\n\t{\n\t\tdata = .; _data = .; __data = .;\n\t\t*(.data)\n\t\t*(.rodata)\n\t\t. = ALIGN(4096);\n\t}\n\t\n\t.bss :\n\t{\n\t\tbss = .; _bss = .; __bss = .;\n\t\t*(.bss)\n\t\t. = ALIGN(4096);\n\t}\n\t\n\tend = .; _end = .; __end = .;\n}\n\t\n"
 document encoding="UTF-8" id="2" owner="1" suffix="1" title="Makefile"
  chunk author="0" content="SOURCES=stage2_s.o stage2_c.o printf.o disk.o io.o\nCFLAGS=-nostdlib -fno-builtin -fno-stack-protector\nLDFLAGS=-Tlinker.ld\nASFLAGS=-f elf\n\nall: $(SOURCES) link\n\nclean:\n\trm *.o stage2.bin\n\nlink:\n\tld $(LDFLAGS) -o stage2.bin $(SOURCES)\n\nstage2_s.o: stage2.s\n\tnasm $(ASFLAGS) -o stage2_s.o stage2.s\n\nstage2_c.o: stage2.c\n\tgcc $(CFLAGS) -c stage2.c -o stage2_c.o\n\t\nprintf.o: printf.c\n\tgcc $(CFLAGS) -c printf.c -o printf.o\n\t\ndisk.o: disk.c\n\tgcc $(CFLAGS) -c disk.c -o disk.o\n\t\nio.o: io.c\n\tgcc $(CFLAGS) -c io.c -o io.o\n\t\nimage: update_image.sh\n\tbash update_image.sh\n\nqemu:\n\tqemu -boot a -fda floppy.img -hda c.img"
 document encoding="UTF-8" id="3" owner="1" suffix="1" title="stage2.c"
  chunk author="0" content="/*\n * stage2.c\n * Copyright (C) 2011 All Rights Reserved © ® ™ Quasar Lab. \\o/\n * loading part of stage2\n * The stage2's job is to get multiboot info, load and jump to the kernel module\n */\n\n#include \"stage2.h\"\n#include \"multiboot.h\"\n\n/*\n * Entry point, called from the ASM file. Main method of stage2\n */\nint main(unsigned long magic, unsigned long addr)\n{        \n    struct multiboot *mboot;\n\n    char *video = (char *)0xB8000;\n    int i = 0;\n    char *cmdline;\n    \n    \n    mboot = (struct multiboot *) addr;\n    \n    /* clear screen */\n    for(i; i < 160*25; i++)\n        *(video + i) = 0;\n        \n    printf(\"Magic number is : %x \\n\", magic);\n    printf(\"Address of the structure is : %x \\n\", addr);\n        \n    if((mboot->flags) & (1 << (11)))\n    {\n        printf(\"GNAGNAGNA VESA \\n\");\n    }\n    else\n        printf(\"pas gnagnagna :'( \\n\");\n    printf(\"Hello world \\n\");\n    printf(\"I am stage2 \\n\");\n    \n    printf(\"%d \\n\", (mboot->flags >> 2) & 0x1);\n    if((mboot->flags >> 2) & 0x1)\n    {\n        cmdline = (char *) mboot->cmd_line;\n        printf(\"%d \\n\", mboot->cmd_line);\n    }\n    else\n        printf(\"No kernel cmdline \\n\");\n    \n    whereami();\n    \n    return 0;\n}\n"
 document encoding="UTF-8" id="4" owner="1" suffix="1" title="stage2.s"
  chunk author="0" content="; stage2.s\n; main entry point in ASM for stage2\n; gets the structure given by the multiboot bootloader and calls the\n; main C method\n\n; multiboot compliance\nMBOOT_PAGE_ALIGN      equ 1<<0\nMBOOT_MEM_INFO        equ 1<<1\nMBOOT_VESA            equ 1<<2\nMBOOT_HEADER_MAGIC    equ 0x1BADB002 ; multiboot magic value\nMBOOT_HEADER_FLAGS    equ MBOOT_PAGE_ALIGN | MBOOT_MEM_INFO | MBOOT_VESA\nMBOOT_CHECKSUM        equ -(MBOOT_HEADER_MAGIC + MBOOT_HEADER_FLAGS)\n\n; VESA\nVESA_MODE             equ 0\nVESA_WIDTH            equ 800\nVESA_HEIGHT           equ 600\nVESA_DEPTH            equ 32\n\n; As the multiboot bootloader as already switched to protected mode,\n; we can use 32 bits instructions\n[BITS 32]\n\n[GLOBAL mboot]\n[EXTERN code]\n[EXTERN bss]\n[EXTERN end]\n\nmboot:\n    dd    MBOOT_HEADER_MAGIC\n    dd    MBOOT_HEADER_FLAGS\n    dd    MBOOT_CHECKSUM\n    dd    mboot\n    dd    code\n    dd    bss\n    dd    end\n    dd    start\n\n; start is our global entry point\n[GLOBAL start]\n\n; make the stage2's C main accessible from this code\n[EXTERN main]\n\nstart:\n    push ebx     ; the multi boot structure\n    push eax   \n    cli          ; shut down interrupts\n    call main  ; enter C code\n    jmp $        ; infinite loop\n"
 document encoding="UTF-8" id="5" owner="1" suffix="1" title="stage2.h"
  chunk author="0" content="#ifndef STAGE2_H\n#define STAGE2_H\n\ninline void outb(unsigned short port, unsigned char value);\ninline unsigned char inb(unsigned short port);\ninline unsigned short inw(unsigned short port);\n\n/*\nstruct multiboot {\n    /* Multiboot version */\n    unsigned int flags;\n\n    /* Available memory */\n    unsigned int mem_lower;\n    unsigned int mem_upper;\n\n    /* Main partition */\n    unsigned int boot_device;\n\n    /* Command line */\n    unsigned int cmd_line;\n\n    /* Boot-Module list */\n    unsigned int mods_count;\n    unsigned int mods_addr;\n    \n    unsigned int syms[4];\n    \n    /* mmap buffer */\n    unsigned int mmap_length;\n    unsigned int mmap_addr;\n    \n    /* Drive info */\n    unsigned int drives_length;\n    unsigned int drives_addr;\n    \n    /* ROM config table */\n    unsigned int config_table;\n    \n    /* MBR name */\n    unsigned int boot_loader_name;\n    \n    /* APM table */\n    unsigned int apm_table;\n    \n    /* VBE */\n    unsigned int vbe_control_info;\n    unsigned int vbe_mode_info;\n    unsigned short vbe_mode;\n    unsigned short vbe_interface_seg;\n    unsigned short vbe_interface_off;\n    unsigned short vbe_interface_leng;\n}__attribute__((packed));\n*/\n\n#define ATA_DISK_MASTER         0x1\n#define ATA_DISK_SLAVE          0x2\n#define ATA_DISK                0x3\n#define ATAPI_DISK              0x4\n\n#define ATA_DATA                0x00\n#define ATA_ERROR               0x01\n#define ATA_PRECOMP             0x01\n#define ATA_SECTOR_COUNT        0x02\n#define ATA_SECTOR_NUMBER       0x03\n#define ATA_CYL_LSB             0x04\n#define ATA_CYL_MSB             0x05\n\n#define ATA_DRIVE               0x06\n#define ATA_DRIVE_IBM           0xA0\n#define ATA_DRIVE_LBA           0x40\n#define ATA_DRIVE_MASTER        0x00\n#define ATA_DRIVE_SLAVE         0x10\n\n#define ATA_STATUS              0x07\n#define ATA_STATUS_ERROR        0x01\n#define ATA_STATUS_INDEX        0x02\n#define ATA_STATUS_CORR         0x04\n#define ATA_STATUS_DRQ          0x08\n#define ATA_STATUS_DSC          0x10\n#define ATA_STATUS_DWF          0x20\n#define ATA_STATUS_DRDY         0x40\n#define ATA_STATUS_BUSY         0x80\n\n#define ATA_CMD                 0x07\n#define ATA_CMD_ATA_IDENT       0xEC\n#define ATA_CMD_ATAPI_IDENT     0xA1\n#define ATA_CMD_READ            0x20\n#define ATA_CMD_WRITE           0x30\n#define ATA_CMD_READ_MULTI      0xC4\n#define ATA_CMD_WRITE_MULTI     0xC5\n#define ATA_CMD_SET_MULTI       0xC6\n#define ATA_CMD_PACKET          0xA0\n\n#define ATA_ALTPORT             0x206\n#define ATA_DEVICE_CONTROL      0x206\n#define ATA_N_IEN               0x02\n#define ATA_RESET               0x04\n#define ATA_4BIT                0x08\n\n/* File systems magic numbers */\n\n#define FS_EXT                  0x83\n\n\n\n#endif /* STAGE2_H */"
 document encoding="UTF-8" id="6" owner="1" suffix="1" title="printf.c"
  chunk author="0" content="#include <stdarg.h>\n\nint x = 0, y = 0;\n\nstatic int strlen(char *s)\n{\n    int ret = 0;\n    while(*s++)\n        ret++;\n    return ret;\n}\n\nstatic void itoa (char *buf, int d, int base)\n{\n    char *p = buf;\n    char *p1, *p2;\n    unsigned long ud = d;\n    int divisor = 10;\n\n    /* If %d is specified and D is minus, put `-' in the head. */\n    if (base == 'd' && d < 0)\n    {\n        *p++ = '-';\n        buf++;\n        ud = -d;\n    }\n    else if (base == 'x')\n        divisor = 16;\n     \n    /* Divide UD by DIVISOR until UD == 0. */\n    do\n    {\n        int remainder = ud % divisor;\n     \n        *p++ = (remainder < 10) ? remainder + '0' : remainder + 'a' - 10;\n    }\n    while (ud /= divisor);\n     \n    /* Terminate BUF. */\n    *p = 0;\n     \n    /* Reverse BUF. */\n    p1 = buf;\n    p2 = p - 1;\n    while (p1 < p2)\n    {\n        char tmp = *p1;\n        *p1 = *p2;\n        *p2 = tmp;\n        p1++;\n        p2--;\n    }\n}\n\n\nvoid putcar(unsigned char c)\n{\n    unsigned char *video, *tmp;\n    video = (unsigned char *)(0xB8000 + 2*x + 160*y);\n    \n    switch(c) {\n    case '\\n':\n        x = 0;\n        y++;\n    break;\n    \n    case 8:\n        if(x) \n        {\n            *(video+1) = 0x0;\n            x--;\n        }\n    break;\n    \n    case 9:\n        x = x + 8 - (x % 8);\n    break;\n    \n    case '\\r':\n        x = 0;\n    break;\n    \n    default:\n        *video = c;\n        *(video + 1) = 0x07;\n        x++;\n        if(x > 79)\n        {\n            x = 0;\n            y++;\n        }\n    break;\n    }\n    \n    if(y > 24)\n    {\n        for(video = (unsigned char *) 0xB8000; video < (unsigned char *)0xB8000 + 160*25; video+=2)\n        {\n            tmp = (unsigned char*) (video + 160*(y - 24));\n            \n            if(tmp < (unsigned char*) (0xB8000 + 160*25))\n            {\n                *video = *tmp;\n                *(video+1) = *(tmp + 1);\n            }\n            else\n            {\n                *video = 0;\n                *(video + 1) = 0x07;\n            }\n        }\n        \n        y -= (y - 24);\n        if(x < 0)\n            x = 0;\n    }\n}   \n        \n\nvoid printf(char *s, ...)\n{\n    va_list ap;\n    char buf[16];\n    int i, j, size, buflen, neg;\n    unsigned char c;\n    int ival;\n    unsigned int uival;\n    \n    va_start(ap, s);\n    \n    while((c = *s++))\n    {\n        size = 0;\n        neg = 0;\n        \n        if(c == 0) /* str end */\n            break;\n            \n        else if(c == '%')\n        {\n            c = *s++;\n            \n            if(c >= '0' && c <= '9')\n            {\n                size = c - '0';\n                c = *s++;\n            }\n            \n            if(c == 'd')\n            {\n                ival = va_arg(ap, int);\n                \n                /* is our number negative ? */\n                if(ival < 0)\n                {\n                    /* yes, store it's absolute value */\n                    uival = 0 - ival;\n                    neg++;\n                }\n                else\n                    uival = ival;\n                    \n                itoa(buf, uival, 'd');\n                buflen = strlen(buf);\n                \n                if(buflen < size)\n                {\n                    for(i = size, j = buflen; i >= 0; i--, j--)\n                        buf[i] = (j >= 0) ? buf[j] : '0';\n                }        \n                \n                if(neg)\n                    printf(\"-%s\", buf);\n                else\n                    printf(\"%s\", buf);\n            }\n            \n            else if(c == 'u')\n            {\n                uival = va_arg(ap, int);\n                itoa(buf, uival, 'd');\n                    \n                buflen = strlen(buf);\n                if(buflen < size)\n                {\n                    for(i = size, j = buflen; i >= 0; i--, j--)\n                        buf[i] = (j >= 0) ? buf[j] : '0';\n                }\n                \n                printf(buf);\n            }\n            \n            else if(c == 'x' || c == 'X')\n            {\n                uival = va_arg(ap, int);\n                itoa(buf, uival, 'x');\n                \n                buflen = strlen(buf);\n                if(buflen < size)\n                {\n                    for(i = size, j = buflen; i >= 0; i--, j--)\n                        buf[i] = (j >= 0) ? buf[j] : '0';\n                }\n                    \n                printf(\"0x%s\", buf);\n            }        \n            \n            else if(c == 's')\n                printf((char *) va_arg(ap, int));\n                \n        }\n        \n        else\n            putcar(c);\n            \n    }\n    \n    return;\n}\n"
 document encoding="UTF-8" id="7" owner="1" suffix="1" title="io.c"
  chunk author="0" content="inline void outb(unsigned short port, unsigned char value)\n{\n    asm volatile(\"outb %%al, %%dx\" :: \"d\" (port), \"a\" (value));\n}\n\ninline unsigned char inb(unsigned short port)\n{\n    unsigned char ret;\n    asm volatile(\"inb %%dx,%%al\":\"=a\" (ret):\"d\" (port));\n    return ret;\n}\n\ninline unsigned short inw(unsigned short port)\n{\n    unsigned short ret;\n    asm volatile(\"inw %%dx,%%ax\":\"=a\" (ret):\"d\" (port));\n    return ret;\n}"
 document encoding="UTF-8" id="8" owner="1" suffix="1" title="disk.c"
  chunk author="0" content="#include \"stage2.h\"\n\nstatic inline void udelay(unsigned int delay)\n{\n    int i;\n    for(i = 0; i < (delay*1000); i++)\n    {\n        i++;\n        i--;\n    }\n}\n\nstatic char *identify_fs(char magic_number)\n{\n    switch(magic_number)\n    {\n        case FS_EXT:\n            return \"Linux EXT\";\n            break;\n        default:\n            return \"Unknown FS\";\n            break;\n    }\n}\n            \n\nstatic void ide_read(long sector, void *buf, unsigned short port, char master)\n{\n    unsigned char cyl_low, cyl_high, sect, head, status;\n    int devselect, i, timeout;\n    short *buffer;\n    \n    if(master == ATA_DISK_MASTER)\n        devselect = ATA_DRIVE_MASTER;\n    else\n        devselect = ATA_DRIVE_SLAVE;\n    \n    outb(port + ATA_DEVICE_CONTROL, ATA_N_IEN | ATA_4BIT);\n    udelay(1);\n    \n    sect = sector & 0xFF;\n    cyl_low = (sector >> 8) & 0xFF;\n    cyl_high = (sector >> 16) & 0xFF;\n    head = ((sector >> 24) & 0x7) | 0x40;\n    \n    /* select the port and the drive */\n    outb(port + ATA_DRIVE, ATA_DRIVE_IBM | devselect);\n    udelay(100);\n    \n    outb(port + ATA_DEVICE_CONTROL, ATA_4BIT);\n    outb(port + ATA_ERROR, 1);\n    outb(port + ATA_PRECOMP, 0);\n    outb(port + ATA_SECTOR_COUNT, 1);\n    outb(port + ATA_SECTOR_NUMBER, sect);\n    outb(port + ATA_CYL_LSB, cyl_low);\n    outb(port + ATA_CYL_MSB, cyl_high);\n    outb(port + ATA_DRIVE, ATA_DRIVE_IBM | devselect | head);\n    \n    /* send the read command */\n    outb(port + ATA_CMD, ATA_CMD_READ);\n    \n    for(timeout = 0; timeout < 30000; timeout++)\n    {\n        status = inb(port + ATA_STATUS);\n        if(!(status & ATA_STATUS_BUSY))\n            break;\n        udelay(1);\n    }\n    \n    buffer = (short *) buf;\n    for(i = 0; i < 256; i++)\n        buffer[i] = inw(port + ATA_DATA);\n}\n\n\nvoid whereami()\n{\n    int i, j, k;\n    /* the 4 ports that we have to test */\n    int ports[4] = {0x1F0, 0x170, 0xF0, 0x70};\n    /* and their  control ports */\n    int ctrl_ports[4] = {0x3F0, 0x370, 0x2F0, 0x270};\n    int port;\n    int ctrl_port;\n    unsigned char bufsect[512];\n\n    printf(\"> Searching for drives and partitions... \\n\");\n\n    /* test each port */\n    for(i = 0; i < 4; i++)\n    {\n        printf(\"> Trying port %d \\n\", i);\n        \n        /* tmp buffers */\n        char byte1, byte2;\n        unsigned char a = 0, b = 0;\n    \n        /* wich port are we gonna use for this iteration ? */\n        port = ports[i];\n        ctrl_port = ctrl_ports[i];\n        \n        /* is our controller present ? */\n        /* je précise que je n'ai rien compris à comment on fait\n           mais qu'apparemment on fait comme ça alors c'est cool */\n        byte1 = inb(port + 6);\n        byte2 = (byte1 & 0x10) >> 4;\n        if(byte2 == 0)\n        {\n            byte1 |= 0x10;\n            outb(port + 6, byte1);\n        }\n        else\n        {\n            byte1 = byte1 & 0xEF;\n            outb(port + 6, byte1);\n        }\n        byte1 = inb(port + 6);\n        byte1 = (byte1 & 0x10) >> 4;\n        if(byte1 != byte2) /* the controller is present */\n        {\n            printf(\">     Found controller \\n\");\n            /* initialize it */\n            outb(ctrl_port + 6, 4);\n            udelay(100); \n            outb(ctrl_port + 6, 0);\n            \n            /* select the master drive */\n            outb(port + ATA_DRIVE, ATA_DRIVE_IBM | ATA_DRIVE_MASTER);\n            udelay(100);\n            \n            /* get sector count and sector number */\n            a = inb(port + ATA_SECTOR_COUNT);\n            b = inb(port + ATA_SECTOR_NUMBER);\n            \n            if((a == 1) && (b == 1))\n            {\n                a = inb(port + ATA_CYL_LSB);\n                b = inb(port + ATA_CYL_MSB);\n                \n                if((a == 0) && (b == 0))\n                {\n                    /* this is an ATA drive */\n                    printf(\">     Found ATA drive. Looking for partitions \\n\");\n                    ide_read(0, &bufsect, port, ATA_DISK_MASTER);\n                    if((bufsect[510] == 0x55) && (bufsect[511] == 0xAA))\n                    {\n                        for(j = 0; j < 4; j++)\n                        {\n                            char *buf = identify_fs(bufsect[450 + j * 16]);\n                            printf(\">           Found partition %s\", buf);\n                        }\n                    }\n                }\n                \n                else if((a == 0x14) && (b == 0xEB))\n                    printf(\">     Found ATAPI drive \\n\");\n            }\n        }\n    }\n}"